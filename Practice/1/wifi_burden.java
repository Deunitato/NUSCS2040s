

import java.util.Arrays;


/*
We use binary search to find the appropriate dist
We guess and check for each number generated by the BS
We multiply 10 to save the decimal pointer

Error Log:
1. Runtime
2. Accuracy


*/

class wifi_burden{
 public static void main(String[] args){

       
	   try(Kattio kattio = new Kattio(System.in)){
         int testCases= kattio.getInt();
		 while(testCases>0){
			 int accessPoints= kattio.getInt();
			 int house_add= kattio.getInt();
			 int[] list = new int[house_add];
			 for(int i=0; i< house_add;i++){
				 int get = kattio.getInt();
				 list[i] = get*10;
			 }
			 Arrays.sort(list);
			 kattio.println(maxDistCounter(list, accessPoints));
		     testCases--;
	     kattio.flush(); //so that it will be delivered to the kattis system, if not flush it will have error in output
		 }
        }

    }
	
	
	public static int calAP(int[] houseList, int maxDist){ //time complex: N
       int apCounter = 1;
	   int pointer = -1;
        for(int add : houseList){
			if(pointer==-1){ //if its first house
				pointer = add + maxDist;
				continue;
			}
			
			//if((pointer+ add+1)/4 <= maxDist){
			if((add-pointer) <= maxDist){
				continue;
			}
			else{
				pointer = add + maxDist;
				apCounter++;
				
			}
			
		}
        return apCounter;		
	}
	
	
	
	public static double maxDistCounter(int[] house_list, int ap){

		
		int high = 10000000;
		int low = 0;
		int calculatedAP = 0;
		int dist =0;
		//boolean flag = false;
		while(high > low){ //search for max dist
		    dist = (high+low) / 2;
			calculatedAP = calAP(house_list, dist);
		/*if(calculatedAP==ap && (dist == 1)){
				//high = dist;
			    break;
			} */
			if(calculatedAP> ap){ // my min dis is too low
				low = dist+1;
			}
			else{
				high = dist;
			}
			
			/*if(high == low){
				return low;
			}*/
		}
		
		//System.out.println(dist);
		//System.out.println(low);
		//low = 0;
		//high = dist;
		
		
		/*
		while(true){ //check if its the minimum possible dist
			calculatedAP = calAP(house_list, dist - 1);
			//System.out.println(calculatedAP);
			if(calculatedAP != ap){
				break;
			}
			dist -- ;
		}
		*/
		
		double second = low % 10;
		return low/10 + second/10;
		//return ((double)low)/10;
	}
	




 }

